#!/usr/bin/python

import curses
import os
import signal
import sys
import threading
import traceback

import init
import musicdb
import socket_thread
            
from loadconf import config as config
import debug


def __inp(disp, qq):
    while True:
        disp.command_event.wait()
        
        key = disp.getkey()
        if key in disp.actions:
            qq.put_nowait((key))
            if key in config.COMMAND:
                disp.command_event.clear()

def main_loop(disp):
    remote = socket_thread.Remote(disp, config.SOCKET)

    threading.Thread(target=__inp, args=(disp,remote,), daemon=True).start()
    while not disp.die:
        disp.draw()

        item = remote.get()

        if type(item) is tuple:
            remote.add_item(item)
        elif item in disp.actions:
            disp.actions[item]()


def cleanup(stdscr, exit_f=False):
    if os.path.exists(config.SOCKET):
        os.remove(config.SOCKET)
    
    curses.echo()
    curses.nocbreak()
    stdscr.keypad(0)

    curses.endwin()

    if exit_f:
        sys.exit()

        
def print_error(reason, error):
    print(reason)
    if error:
        print(error)
    print(traceback.format_exc())

def main():
    if os.path.exists(config.SOCKET):
        sys.exit('sqlmp socket already open')
    
    try:
        stdscr = init.ncurses()
    except Exception as e:
        cleanup(stdscr)
        print_error('curses error:', e)
        return

    try:
        db = musicdb.Musicdb(config.DBPATH, config.LIBPATH)
    except Exception as e:
        cleanup(stdscr)
        print_error('db error:', e)

    try:
        signal.signal(signal.SIGINT, lambda a, b: cleanup(stdscr, True))
        disp = init.windows(db, stdscr)
        main_loop(disp)
        cleanup(stdscr)

    except Exception as e:
        cleanup(stdscr)
        print_error('error:', e)


if __name__ == "__main__":
    main()

