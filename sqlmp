#!/usr/bin/python

import curses
import os
import signal
import sys
import threading

import debug
import init
import musicdb
import socket_thread
            
from loadconf import config as config


def __inp(ui, qq):
    while True:
        ui.command_event.wait()

        key = ui.stdscr.get_wch()
        if ui.inp:
            ui.handle_input(key)
        elif key in ui.actions:
            qq.put_nowait((key))

            if key in config.COMMAND:
                ui.command_event.clear()


def main_loop(ui):
    remote = socket_thread.Remote(ui, config.SOCKET)

    threading.Thread(target=__inp, args=(ui, remote, ), daemon=True).start()

    while not ui.die:
        #this call blocks
        item = remote.get()

        #if item is from remote it is a tuple
        #otherwise it's a keypress
        if type(item) is tuple:
            remote.add_item(item)
        elif item in ui.actions:
            ui.actions[item]()


def cleanup(stdscr, exit_f=False):
    if os.path.exists(config.SOCKET):
        os.remove(config.SOCKET)
    
    curses.echo()
    curses.nocbreak()
    stdscr.keypad(0)

    curses.endwin()

    if exit_f:
        sys.exit()


def main():
    if os.path.exists(config.SOCKET):
        sys.exit('sqlmp socket already open')
    
    stdscr = init.ncurses()

    try:
        db = musicdb.Musicdb(config.DBPATH, config.LIBPATH)
    except Exception as e:
        debug.print_error('db error:', e)

    try:
        signal.signal(signal.SIGINT, lambda a, b: cleanup(stdscr, True))
        ui = init.windows(db, stdscr)
        main_loop(ui)
        cleanup(stdscr)
    except Exception as e:
        cleanup(stdscr)
        debug.print_error('error:', e)


if __name__ == "__main__":
    main()

